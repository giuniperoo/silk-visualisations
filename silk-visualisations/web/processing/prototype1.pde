/************************************************************** * name:        Prototype 1                                   * *                                                            * * description: Renders a bar chart depicting a view of match * *              quantities and confidence score distribution  * *              for multiple files.                           * *                                                            * * date:        July 2011                                     * * author:      tgiunipero                                    * * version:     1.0                                           * **************************************************************/// Chart parametersint TOP_BOUND = 90;int LEFT_BOUND = 80;int RIGHT_BOUND = 790;int BOTTOM_BOUND = 490;// number of columns to displayint columnNumber;// Text for x and y axesString xAxisText = "confidence score";String yAxisText = "number of generated matches";// Column width in pixelsfloat columnWidth;// Float values mark the start of each column along x-axisfloat[] columnRanges;// Height of each unit (in pixels) plotted along y-axis// e.g., if there are 8 units in column n, n will be 8*unitHeight tallint unitHeight;// Upper bound for maximum number of matchesint upperBound;void setup() { /* Initialise canvas properties */    size(850, 560);    textFont(createFont("trebuchet ms",13));    noLoop(); /* Initialise colour palette */    colours = new ArrayList();    colours.add(RED);    colours.add(BLUE);    colours.add(PURPLE); /* Uncomment for testing */ // testSampleData(0.6, 1, 300);}void draw() {    fill(80);    stroke(80);    textSize(13);    background(#fcfcfc);    // clears screen for redraw /* Initialise column properties */    // base columns on grouping number    columnNumber = groupingNumber;    columnWidth = getColumnWidth();    columnRanges = new float[columnNumber];    // Divide columns by pixel ranges    for (int i=0; i<columnNumber; i++) {        columnRanges[i] = columnWidth * i;    } /* Render chart if data is loaded */    if (currentlySelected.length > 0) {        // get maximum value for y-axis        int maxValue = getMaxValue();        // Set upper bound for y-axis        upperBound = getUpperBound(maxValue);        // Set unit height according to upperBound        setUnitHeight(upperBound);        // Display axes        line(LEFT_BOUND-1, BOTTOM_BOUND, RIGHT_BOUND, BOTTOM_BOUND);    // x-axis        line(LEFT_BOUND-1, TOP_BOUND, LEFT_BOUND-1, BOTTOM_BOUND-1);    // y-axis        line(LEFT_BOUND-2, TOP_BOUND, LEFT_BOUND-6, TOP_BOUND);         // top tick        line(RIGHT_BOUND, BOTTOM_BOUND+1, RIGHT_BOUND, BOTTOM_BOUND+5); // right tick        // Display numbers for axes        text(lowerThreshold, (LEFT_BOUND-1) - textWidth(lowerThreshold)/2, BOTTOM_BOUND + 23);        text(upperThreshold, RIGHT_BOUND - textWidth(upperThreshold)/2, BOTTOM_BOUND + 23);        text("0", LEFT_BOUND - 20, BOTTOM_BOUND + 5);        text(upperBound, LEFT_BOUND - 13 - textWidth(upperBound), TOP_BOUND + 5);        // Text along x-axis        textSize(18);        text(xAxisText,             (LEFT_BOUND-1 + RIGHT_BOUND)/2 - textWidth(xAxisText)/2,   // x-coordinate             BOTTOM_BOUND + textAscent()+30);                           // y-coordinate        // Text along y-axis        pushMatrix();        rotate(-HALF_PI);        text(yAxisText,             -((TOP_BOUND + BOTTOM_BOUND)/2 + textWidth(yAxisText)/2),  // x-coordinate             LEFT_BOUND-45);                                            // y-coordinate        popMatrix();     /* Render the data */        noStroke();        for (int i=0; i<currentlySelected.length; i++) {            // get colour            int c = currentlySelected[i].selectionColour;            fill(colours.get(c));                                       // set bar colour            for (int j=0; j<sketchData[i].length; j++) {                ArrayList currentColumn = sketchData[i][j];                columnSize = currentColumn.length;                if (columnSize != 0) {                    rect(LEFT_BOUND+1 + (j*columnWidth),                // x-coordinate                         BOTTOM_BOUND - (columnSize * unitHeight),      // y-coordinate                         columnWidth-1,                                 // width                         (columnSize * unitHeight) -2);                 // height                }            }        }        // Display intermediate measures        displayIntermediateMeasures();     /* Display results for total matches */        fill(80);        stroke(80);        int totalCount;        String firstFileName, secondFileName;        for (int i=0; i<currentlySelected.length; i++) {            totalCount = 0;            for (int j=0; j<sketchData[i].length; j++) {                ArrayList currentColumn = sketchData[i][j];                columnSize = currentColumn.length;                if (columnSize != 0) {                    totalCount += columnSize;                }            }            if (i==0) { int firstFileCount = totalCount; }            if (i==1) { int secondFileCount = totalCount; }        }     /* Display box for total matches */        // Get file names        // First file        int firstIdx = currentlySelected[0].fileIdx;        firstFileName = fileData[firstIdx].name;        // Second file        if (currentlySelected.length > 1) {            int secondIdx = currentlySelected[1].fileIdx;            secondFileName = fileData[secondIdx].name;        }        // base width on length of longest text string        textSize(12);        int txtWidth;        if (textWidth(firstFileName + ":  " + firstFileCount) >            textWidth(secondFileName + ":  " + secondFileCount)) {            txtWidth = textWidth(firstFileName + ":  " + firstFileCount);        } else {            txtWidth = textWidth(secondFileName + ":  " + secondFileCount);        }        // base height on whether two files or one to display        int boxHeight;        if (secondFileName == null) {            boxHeight = 50;        } else {            boxHeight = 70;        }        strokeJoin(ROUND);        fill(#e7e5da);        noStroke();        beginShape();          vertex(width-txtWidth-30, boxHeight+10);          vertex(width-txtWidth-30, 10);          vertex(width-16, 10);          vertex(width-10, 16);          vertex(width-10, boxHeight+10);          vertex(width-txtWidth-30, boxHeight+10);        endShape();        arc(width-16, 16, 12, 12, TWO_PI-PI/2, TWO_PI);        fill(80);        stroke(80);        textSize(13);        text("Total matches:", width-txtWidth-25, 30);        textSize(12);        text(firstFileName + ":  " + firstFileCount, width-txtWidth-20, 50);        if (secondFileName != null) {            text(secondFileName + ":  " + secondFileCount, width-txtWidth-20, 70);        }    }}void displayIntermediateMeasures() {    fill(80);    textSize(12);   // smaller text  /* -------------------------- x-axis -------------------------- *   * If there are less than 5 tenths to display, display median   *   * values between tenths. Otherwise, only display tenth values. */    // get width in pixels per tenth unit    thresholdRange = (upperThreshold - lowerThreshold);    numberOfTenths = thresholdRange*10;    widthInPixels = (RIGHT_BOUND - LEFT_BOUND);    widthPerUnit = widthInPixels/numberOfTenths;    int j=1;    if (thresholdRange/.1 < 5) {        for (int i=float(lowerThreshold)+.05; i<float(upperThreshold); i+=.05) {            i = round(i*100)/100;           // avoids long floats, e.g. '0.6999999999999'            // prepare text            txt = i.toString().slice(0,4);            // display text            text(txt,                 (LEFT_BOUND-1) + widthPerUnit/2*j - textWidth(txt)/2,  // x-coordinate                 BOTTOM_BOUND + 19);                                    // y-coordinate            // display tick            stroke(#fcfcfc);            strokeWeight(2);            line((LEFT_BOUND-1) + widthPerUnit/2*j,                 BOTTOM_BOUND-1,                 (LEFT_BOUND-1) + widthPerUnit/2*j,                 BOTTOM_BOUND+1);            stroke(80);            strokeWeight(1);            j++;        }    } else {        for (int i=float(lowerThreshold)+.1; i<float(upperThreshold); i+=.1) {            i = round(i*10)/10;             // avoids long floats            txt = i.toString().slice(0,3);  // prepare text            // display text            text(txt,                 (LEFT_BOUND-1) + widthPerUnit*j - textWidth(txt)/2,    // x-coordinate                 BOTTOM_BOUND + 19);                                    // y-coordinate            // display tick            stroke(#fcfcfc);            strokeWeight(2);            line((LEFT_BOUND-1) + widthPerUnit*j,                 BOTTOM_BOUND-1,                 (LEFT_BOUND-1) + widthPerUnit*j,                 BOTTOM_BOUND+1);            stroke(80);            strokeWeight(1);            j++;        }    }  /* ----------------------- y-axis ----------------------- *   * Attempt to find a suitable divisor, then display each. */    int height = BOTTOM_BOUND - TOP_BOUND;    int divisor;    if (upperBound%5 == 0) {        divisor = 5;    } else if (upperBound%3 == 0) {        divisor = 3;    } else {        divisor = 4;    }    int unit = upperBound/divisor;    int unitHeight = height/divisor;    for (j=1; j<divisor; j++) {        text(unit*j,             LEFT_BOUND - 11 - textWidth(unit*j),   // x-coordinate             (BOTTOM_BOUND + 5) - unitHeight*j);    // y-coordinate        stroke(#fcfcfc);        strokeWeight(2);        // note: this draws a line across the chart, so that lines appear in data        // columns (for this reason, this method is called after the data is drawn        line(LEFT_BOUND-2,             BOTTOM_BOUND - unitHeight*j,             RIGHT_BOUND,             BOTTOM_BOUND - unitHeight*j);        stroke(80);        strokeWeight(1);    }}/* Test to generate an decreasing number of samples    * * based on the number of columns. For example, with   * * 100 columns, the left-most column will contain 100  * * elements whilst the right-most column will end up   * * containing 1.                                       * *                                                     * * Specify lower and upper confidence score thresholds * * and column number as function arguments.            */void testSampleData(float lowerThresh, float upperThresh, int columnNumber) {    int i, j;    // Calculate threshold range    thresholdRange = (upperThresh - lowerThresh);    // set grouping number to column number    groupingNumber = columnNumber;    // Create new array of arrays to hold data for sketch and...    Array[] data = new Array[columnNumber];    // ...enter it into sketchData    sketchData.push(data);    // Initialise ArrayLists; create and add data    for (i=0; i<columnNumber; i++) {        data[i] = new Array[1];        for (j=columnNumber-2-i; j>=0; j--) {            confScore = (thresholdRange/columnNumber) * i + lowerThresh;            data[i].push(confScore);        }    }    // Set global vars    lowerThreshold = lowerThresh.toString().slice(0,3);    upperThreshold = upperThresh;    // Get maximum value for y-axis    int maxValue = getMaxValue();    // Set upper bound for y-axis    upperBound = getUpperBound(maxValue);    setUnitHeight(upperBound);    // Add a bogus entry to currentlySelected    currentlySelected[0] = {'fileIdx' : 0, 'selectionColour' : 0};    // Add a bogus file name    fileData.push({name: "bogus_file.xml"});    // call external JavaScript function    // to render within the first tab    toggleDisplay(0);   // 0 = index of tab 1    columnWidth = getColumnWidth();    columnRanges = new float[columnNumber];    // Divide columns by pixel ranges    for (int i=0; i<columnNumber; i++) {        columnRanges[i] = columnWidth * i;    }    inspectGlobalVars();}/* Output to console the global variables defined for this run */void inspectGlobalVars() {    println("Chart boundaries:");    println("----------------------------");    println("\tLEFT_BOUND:\t" + LEFT_BOUND);    println("\tRIGHT_BOUND:\t" + RIGHT_BOUND);    println("\tTOP_BOUND:\t" + TOP_BOUND);    println("\tBOTTOM_BOUND:\t" + BOTTOM_BOUND);    println("----------------------------");    println("Number of columns:\t" + columnNumber);    println("Column width:\t\t" + columnWidth);    println("Unit height:\t\t" + unitHeight);    println("Max value for y-axis:\t" + getMaxValue());    println("Upper bound for y-axis:\t" + upperBound);    println("----------------------------");    println("Starting points for each column along x-axis:");    for (int i = 0; i < columnRanges.length; i++) {        println(columnRanges[i]);    }}/* Popup functionality */void mouseMoved() {    if (sketchData.length != 0) {        redraw();        // Check if mouse is being hovered over the chart...        if ( mouseX >= LEFT_BOUND && mouseX <= RIGHT_BOUND &&             mouseY >= TOP_BOUND && mouseY <= BOTTOM_BOUND ) {            // If so, determine which column...            currentCol = null;            for (int i=0; i<columnRanges.length; i++) {                if (mouseX <= LEFT_BOUND + columnRanges[i] + columnWidth) {                    currentCol = i;                    break;                }            }            // Check if there's data            // In order to handle more than one file, loop through multiple            // files and temporarily save column details in colDetails            Array colDetails = new Array();            for (int i=0; i<currentlySelected.length; i++) {                int fileIdx = currentlySelected[i].fileIdx;                // retrieve quantity of matches                if (sketchData[i][currentCol].length != 0) {                    // if so, determine if mouseY is within range of the current column...                    int quantity = sketchData[i][currentCol].length;                    int colHeight = quantity * unitHeight;                    if (mouseY <= BOTTOM_BOUND && mouseY >= (BOTTOM_BOUND - colHeight)) {                        // Temporarily store colour index and height value                        colDetails.push({ 'colourIdx' : i, 'colHeight' : colHeight});                    }                }            }            // get the colHeight whose value is lowest, and display popup accordingly            if (colDetails.length > 0) {                Object minColumn = colDetails[0];                int colHeight, colourIdx=-1;                if (colDetails.length > 1) {                    for (int i=1; i<colDetails.length; i++) {                        if (colDetails[i].colHeight < minColumn.colHeight) {                            minColumn = colDetails[i];                        } else if (colDetails[i].colHeight == minColumn.colHeight) {                          // Set shared colour if heights are equal                          // Note: assumes only two files are being compared                          // '2' represents index of shared colour in colours array                          colourIdx = 2;                        }                    }                }                if (colourIdx == -1) { colourIdx = minColumn.colourIdx; }                int colHeight = minColumn.colHeight;                // highlight column                highlightColumn(currentCol, colourIdx, colHeight);                // display info bubble                displayBubble(currentCol, colourIdx, colHeight);            }        }    }}void highlightColumn(col, colourIdx, colHeight) {    // left border    leftBound = LEFT_BOUND+1 + columnRanges[col];    // right border    rightBound = leftBound + (columnWidth-1);    // top border    topBound = BOTTOM_BOUND - colHeight+1;    // height    colHeight -= 3;  // shifts base of column up by 1px    // width    colWidth = rightBound - leftBound;    // get colour    int c;    if (colourIdx == 2) { c = 2; }    else {        c = currentlySelected[colourIdx].selectionColour;    }    fill(colours.get(c), 100);    stroke(colours.get(c), 110);    // render popup column    rect(leftBound, topBound, colWidth, colHeight);}void displayBubble(col, fileIdx, colHeight) { /* Get details */    String fileName;    if (fileIdx == 2) {     // files have equal quantity        fileName = "[ Each file ]";    } else {        fileName = fileData[fileIdx].name;    }    int quantity = int(colHeight/unitHeight);    // get range    thresholdRange = (upperThreshold - lowerThreshold);    confidenceScoreRangePerGrouping =            thresholdRange / groupingNumber;    // get confidence score range for selected column    int lowerValue = (col * confidenceScoreRangePerGrouping) + float(lowerThreshold);    int upperValue = lowerValue + confidenceScoreRangePerGrouping;    // display only 3 significant digits    lowerValue = round(lowerValue*1000)/1000;    upperValue = round(upperValue*1000)/1000;    String rangeText = "Range: " + lowerValue + " - " + upperValue;    // determine which of the three text strings is longest,    // and base the bubble width on that measurement    int txtWidth;    if (textWidth(quantity + " matches") > textWidth(fileName)) {        txtWidth = textWidth(quantity + " matches");    } else {        txtWidth = textWidth(fileName);    }    if (textWidth(rangeText) > txtWidth) {        txtWidth = textWidth(rangeText)    } /* Render popup box */    // left border    float leftBound = LEFT_BOUND + columnRanges[col] + columnWidth/2 - txtWidth/2 - 7;    // right border    float rightBound = LEFT_BOUND + columnRanges[col] + columnWidth/2 + txtWidth/2 + 7;    // top border    float topBound = BOTTOM_BOUND - colHeight;    strokeJoin(ROUND);    fill(#ffffff);    beginShape();      vertex(leftBound, topBound - 7);      vertex(leftBound, topBound - 72);      vertex(rightBound, topBound - 72);      vertex(rightBound, topBound - 7);      vertex(LEFT_BOUND + columnRanges[col] + columnWidth/2 + 3, topBound - 7);      vertex(LEFT_BOUND + columnRanges[col] + columnWidth/2, topBound - 2);      vertex(LEFT_BOUND + columnRanges[col] + columnWidth/2 - 3, topBound - 7);      vertex(leftBound, topBound - 7);    endShape();/* Display text */    fill(80);    if (quantity == 1) {        text(quantity + " match",             LEFT_BOUND + columnRanges[col] + columnWidth/2 - textWidth(quantity + " matches")/2,             topBound - 55);    } else {        text(quantity + " matches",             LEFT_BOUND + columnRanges[col] + columnWidth/2 - textWidth(quantity + " matches")/2,             topBound - 55);    }    text(fileName,         LEFT_BOUND + columnRanges[col] + columnWidth/2 - textWidth(fileName)/2,         topBound - 35);    text(rangeText,         LEFT_BOUND + columnRanges[col] + columnWidth/2 - textWidth(rangeText)/2,         topBound - 15);}