/************************************************************************ * name:        Prototype 3                                             * *                                                                      * * description: Renders a scatterplot that shows how the confidence     * *              scores of matches occurring in both jobs change between * *              job runs.  Points along the diagonal indicate that the  * *              confidence scores of shared matches have not changed    * *              between runs.  Clusters that appear outside of the      * *              diagonal demonstrate whether scores tend to increase    * *              or decrease between runs.                               * *                                                                      * * date:        July 2011                                               * * author:      tgiunipero                                              * * version:     1.0                                                     * ************************************************************************/// Chart parametersint TOP_BOUND = 50;int LEFT_BOUND = 260;int RIGHT_BOUND = 790;int BOTTOM_BOUND = 490;// Width and height of chartint widthInPixels;int heightInPixels;// Maximum quantity of shared matches for loaded dataint maxQuantity;// Flags to determine whether a user is hovering over a displayed matchboolean mouseOverMatch;boolean previousMouseOverMatch;void setup() { /* Initialise canvas properties */    noLoop();    size(850, 560);    textFont(createFont("trebuchet ms",13));    widthInPixels = RIGHT_BOUND - LEFT_BOUND;    heightInPixels = BOTTOM_BOUND - TOP_BOUND;    mouseOverMatch = false; /* Initialise colour palette */    colours = new ArrayList();    colours.add(RED);    colours.add(BLUE);    colours.add(PURPLE);}void draw() {    fill(80);    stroke(80);    textSize(13);    background(#fcfcfc);    // clears screen for redraw /* Render chart axes if at least one file is loaded */    if (sketchData.length > 0) {     /* Display axes */        line(LEFT_BOUND, BOTTOM_BOUND, RIGHT_BOUND, BOTTOM_BOUND);      // x-axis        line(LEFT_BOUND, TOP_BOUND, LEFT_BOUND, BOTTOM_BOUND-1);        // y-axis        line(LEFT_BOUND-1, TOP_BOUND, LEFT_BOUND-5, TOP_BOUND);         // top tick        line(RIGHT_BOUND, BOTTOM_BOUND+1, RIGHT_BOUND, BOTTOM_BOUND+5); // right tick     /* Display numbers for axes */        text(lowerThreshold, LEFT_BOUND - 10 - textWidth(lowerThreshold), BOTTOM_BOUND + 19);        text(upperThreshold, RIGHT_BOUND - textWidth(upperThreshold)/2, BOTTOM_BOUND + 23);        text(upperThreshold, LEFT_BOUND - 11 - textWidth(upperThreshold), TOP_BOUND + 5);     /* Display diagonal */        stroke(180);                                            // draw diagonal lighter        line(LEFT_BOUND, BOTTOM_BOUND, RIGHT_BOUND, TOP_BOUND);        stroke(80);     /* Display intermediate measures */        displayIntermediateMeasures();     /* Display box for Δ percentages */        strokeJoin(ROUND);        fill(#e7e5da);        noStroke();        beginShape();          vertex(10, height-16);          vertex(10, height-83);          vertex(165, height-83);          vertex(165, height-10);          vertex(16, height-10);        endShape();        arc(16, height-16, 12, 12, PI/2, PI);        fill(80);        stroke(80);    } /* Display data if two or more files are loaded */    if (sketchData.length > 1) {     /* Display x and y-axis text */        // Text for x and y axes        // Left file        int firstIdx = currentlySelected[0].fileIdx;        leftFileName = fileData[firstIdx].name;        // Right file        int secondIdx = currentlySelected[1].fileIdx;        rightFileName = fileData[secondIdx].name;        String xAxisText = "confidence score [ " + leftFileName + " ]";        String yAxisText = "confidence score [ " + rightFileName + " ]";        // Text along x-axis        textSize(17);        text(xAxisText,             (LEFT_BOUND-1 + RIGHT_BOUND)/2 - textWidth(xAxisText)/2,   // x-coordinate             BOTTOM_BOUND + textAscent()+30);                           // y-coordinate        // Text along y-axis        pushMatrix();        rotate(-HALF_PI);        text(yAxisText,             -((TOP_BOUND + BOTTOM_BOUND)/2 + textWidth(yAxisText)/2),  // x-coordinate             LEFT_BOUND-50);                                            // y-coordinate        popMatrix();     /* Display the data */        fill(colours.get(2));                                           // set colour        stroke(colours.get(2), 200);        // get highest quantity instance        for (int i=0; i<confScoreDelta.length; i++) {            if (maxQuantity < confScoreDelta[i][1]) {                maxQuantity = confScoreDelta[i][1];            }        }        if (maxQuantity < 10) { maxQuantity = 10; }  // ensures the c value will                                                     // double in the for loop below        int totalIncrease, totalDecrease; // keep track of the number of shared matches                                          // that increase or decrease between files        for (int i=0; i<confScoreDelta.length; i++) {            String item = confScoreDelta[i][0];            token = item.indexOf(",");            leftScore = item.substring(0,token);            rightScore = item.substring(token+1);            xOffset = leftScore - lowerThreshold;            yOffset = rightScore - lowerThreshold;            xCoord = LEFT_BOUND + (xOffset / thresholdRange * widthInPixels);            yCoord = BOTTOM_BOUND - (yOffset / thresholdRange * heightInPixels);            quantity = confScoreDelta[i][1];            // record whether match instance increased or decreased between files            if (leftScore > rightScore) {                totalDecrease += quantity;            } else if (leftScore < rightScore) {                totalIncrease += quantity;            }            // render the data            if (quantity == 1) {                ellipse(xCoord, yCoord, 4, 4);            } else {                ellipse(xCoord, yCoord, 4, 4);                noStroke();                alpha = 80;                diameter = 15;             /* Suppose maxQuantity == 500;           *              * Quantity grouping = 500/5 => 100, so: *              *     qty           diameter            *              *     1               5 px              *              *     2-100          15 px              *              *     101-200        25 px              *              *     201-300        35 px              *              *     301-400        45 px              *              *     401-500        55 px              */                for (c=2; c<=quantity; c+=maxQuantity/5) {  // maximum of 5 outer rings                    fill(colours.get(2), alpha);                    ellipse(xCoord, yCoord, diameter, diameter);                    diameter += 10;                    if (alpha <= 40) { alpha -= 10; }                    else { alpha -= 20; }                }                fill(colours.get(2));                stroke(colours.get(2), 200);            }        }     /* Display semi-circle indicating diameter of maximum value */        arc(70, height - 150, 4, 4, -PI, 0);        noStroke();        alpha = 80;        diameter = 15;        quantity = maxQuantity;        for (c=2; c<=quantity; c+=maxQuantity/5) {            fill(colours.get(2), alpha);            arc(70, height - 150, diameter, diameter, -PI, 0);            diameter += 10;            if (alpha <= 40) { alpha -= 10; }            else { alpha -= 20; }        }        fill(80);        stroke(80);        textSize(11);        // indicate maximum measure beneath semi-circle        line(43, height - 140, 97, height - 140);     // horizontal line        line(43, height - 141, 43, height - 144);     // left tick        line(97, height - 141, 97, height - 144);     // right tick        line(70, height - 139, 70, height - 136);     // bottom tick        text(maxQuantity + " matches", 70 - textWidth(maxQuantity + " matches")/2, height - 124);     /* Display results for independent/shared matches */        int sharedCount;        for (int i=0; i<confScoreDelta.length; i++) {            sharedCount += confScoreDelta[i][1];        }        // get percentage values        totalIncrease = round(totalIncrease/sharedCount*100);        totalDecrease = round(totalDecrease/sharedCount*100);        textSize(13);        text("Δ confidence scores:", 22, height-63);        textSize(12);        text("Increase:  " + totalIncrease + "%", 30, height-43);        text("Decrease:  " + totalDecrease + "%", 30, height-23);    } /* Uncomment for testing */    // if (sketchData.length != 0) {inspectGlobalVars();}}// set maximum value for y-axis based on loaded datavoid setMaxValue() {    int currentMaxSize = 0;    for (int i=0; i<sketchData.length; i++) {        ArrayList[] data = sketchData[i];        for (int j=0; j<data.length; j++) {            if (data[j].size() > currentMaxSize) {                currentMaxSize = data[j].size();            }        }    }    // TODO: In the event that a file is removed, maxValue    // can decrease - this scenario must be handled    // Update:  Try handling it by simply commenting out the if statement    if (maxValue == null || currentMaxSize > maxValue) {        // Get an upper bound on the max value        int upperBound = null;        int length = nf(currentMaxSize, 0).length();        switch(length) {          case 1:           // currentMaxSize is less than 10            upperBound = 10;            break;          case 2:           // "    "    "    "  less than 100            upperBound = 100;            break;          case 3:           // "    "    "    "  less than 1000            upperBound = 1000;            break;          case 4:           // "    "    "    "  less than 10,000            upperBound = 10000;            break;          case 5:           // "    "    "    "  less than 100,000            upperBound = 100000;            break;          case 6:           // "    "    "    "  less than 1,000,000            upperBound = 1000000;            break;          case 7:           // "    "    "    "  less than 10,000,000            upperBound = 10000000;            break;          case 8:           // "    "    "    "  less than 100,000,000            upperBound = 100000000;            break;          default:            upperBound = currentMaxSize;        }        // While currentMaxSize is less than half of        // upperBound, reduce the upperBound by half        // In other words, if:        //        //     currentMaxSize == 1200 and upperBound == 10000,        //     then upperBound will first be reduced to: 5000        //                                         then: 2500        //                                         then: 1250        //        while (currentMaxSize < upperBound/2) { upperBound /= 2; }        // Set global variable        maxValue = upperBound;    }}// Set the confidence score range based on data contained in sketchDatavoid setConfScoreRange() {    min = 1;    max = 0;    for (int i=0; i<sketchData.length; i++) {     /* Get minimum confidence score */        // Start from the first column and move right        // until a column is found that contains a value        for (int j=0; j<sketchData[i].length; j++) {            if (sketchData[i][j].size() != 0) {                for (int k=0; k<sketchData[i][j].size(); k++) {                    currentConfValue = sketchData[i][j].get(k);                    if (currentConfValue < min) {                        min = currentConfValue;                    }                }                break;            }        }     /* Get maximum confidence score */        // Start from the final column and move left        // until a column is found that contains a value        finalColumn = sketchData[i].length-1;        for (int j=finalColumn; j>=0; j--) {            if (sketchData[i][j].size() != 0) {                for (int k=0; k<sketchData[i][j].size(); k++) {                    currentConfValue = sketchData[i][j].get(k);                    if (currentConfValue > max) {                        max = currentConfValue;                    }                }                break;            }        }    } /* Set global vars */    lowerThreshold = min.toString().slice(0,3);    upperThreshold = max.toString().slice(0,3);}void displayIntermediateMeasures() {    textSize(12);   // smaller text  /* If there are less than 5 tenths to display, display median   *   * values between tenths. Otherwise, only display tenth values. */    // get width and height in pixels per tenth unit    thresholdRange = (upperThreshold - lowerThreshold);    numberOfTenths = thresholdRange*10;    widthInPixels = (RIGHT_BOUND - LEFT_BOUND);    heightInPixels = (BOTTOM_BOUND - TOP_BOUND);    widthPerUnit = widthInPixels/numberOfTenths;    heightPerUnit = heightInPixels/numberOfTenths;    int j=1;    if (thresholdRange/.1 < 5) {        for (int i=float(lowerThreshold)+.05; i<float(upperThreshold); i+=.05) {            i = round(i*100)/100;           // avoids long floats, e.g. '0.6999999999999'            // prepare text            txt = i.toString().slice(0,4);        /* x-axis */            text(txt,                 (LEFT_BOUND-1) + widthPerUnit/2*j - textWidth(txt)/2,  // x-coordinate                 BOTTOM_BOUND + 19);                                    // y-coordinate            stroke(#fcfcfc);            strokeWeight(2);            line((LEFT_BOUND-1) + widthPerUnit/2*j,                     // display tick                 BOTTOM_BOUND-1,                 (LEFT_BOUND-1) + widthPerUnit/2*j,                 BOTTOM_BOUND+1);            stroke(80);            strokeWeight(1);        /* y-axis */            text(txt,                 LEFT_BOUND - 11 - textWidth(txt),                      // x-coordinate                 (BOTTOM_BOUND + 5) - heightPerUnit/2*j);               // y-coordinate            stroke(#fcfcfc);            strokeWeight(2);            line(LEFT_BOUND-1,                                          // display tick                 BOTTOM_BOUND - heightPerUnit/2*j,                 LEFT_BOUND+1,                 BOTTOM_BOUND - heightPerUnit/2*j);            stroke(80);            strokeWeight(1);            j++;        }    } else {        for (int i=float(lowerThreshold)+.1; i<float(upperThreshold); i+=.1) {            i = round(i*10)/10;             // avoids long floats            txt = i.toString().slice(0,3);  // prepare text        /* x-axis */            text(txt,                 (LEFT_BOUND-1) + widthPerUnit*j - textWidth(txt)/2,    // x-coordinate                 BOTTOM_BOUND + 19);                                    // y-coordinate            stroke(#fcfcfc);            strokeWeight(2);            line((LEFT_BOUND-1) + widthPerUnit*j,                       // display tick                 BOTTOM_BOUND-1,                 (LEFT_BOUND-1) + widthPerUnit*j,                 BOTTOM_BOUND+1);            stroke(80);            strokeWeight(1);        /* y-axis */            text(txt,                 LEFT_BOUND - 11 - textWidth(txt),                      // x-coordinate                 (BOTTOM_BOUND + 5) - heightPerUnit*j);                 // y-coordinate            stroke(#fcfcfc);            strokeWeight(2);            line(LEFT_BOUND-1,                                          // display tick                 BOTTOM_BOUND - heightPerUnit*j,                 LEFT_BOUND+1,                 BOTTOM_BOUND - heightPerUnit*j);            stroke(80);            strokeWeight(1);            j++;        }    }}/* Output to console the global variables defined for this run */void inspectGlobalVars() {    println("Chart boundaries:");    println("----------------------------");    println("\tLEFT_BOUND:\t" + LEFT_BOUND);    println("\tRIGHT_BOUND:\t" + RIGHT_BOUND);    println("\tTOP_BOUND:\t" + TOP_BOUND);    println("\tBOTTOM_BOUND:\t" + BOTTOM_BOUND);    println("----------------------------");    println("Number of groups:\t" + groupingNumber);    println("Column width:\t\t" + columnWidth);    println("Unit height:\t\t" + unitHeight);    println("Max value for y-axis:\t" + maxValue);    println("----------------------------");    println("Starting points for each column along x-axis:");    for (int i = 0; i < columnRanges.length; i++) {        println(columnRanges[i]);    }}/* Popup functionality */void mouseMoved() {    if (sketchData.length > 1) {        // Check if mouse is being hovered over the chart        if ( mouseX >= LEFT_BOUND &&             mouseX <= RIGHT_BOUND &&             mouseY >= TOP_BOUND &&             mouseY <= BOTTOM_BOUND ) {            previousMouseOverMatch = mouseOverMatch;            int delta, xCoord, yCoord, diameter, quantity;            float leftScore, rightScore;            for (delta=0; delta<confScoreDelta.length; delta++) {                String item = confScoreDelta[delta][0];    // Note: This finds the first matching instance.                token = item.indexOf(",");                 // If the instance has a large quantity and there                                                           // are other single-quantity instances within its                leftScore = item.substring(0,token);       // circumference, it will not be possible to trigger                rightScore = item.substring(token+1);      // mouseover functionality for these.  TODO: fix!                xOffset = leftScore - lowerThreshold;                yOffset = rightScore - lowerThreshold;                xCoord = LEFT_BOUND + (xOffset / thresholdRange * widthInPixels);                yCoord = BOTTOM_BOUND - (yOffset / thresholdRange * heightInPixels);                quantity = confScoreDelta[delta][1];  // get number of matches                diameter = 5;   // assume quantity == 1                if (quantity > 1) {                    // determine diameter based on quantity                    for (c=2; c<=quantity; c+=maxQuantity/5) {                        diameter += 10;                    }                }                mouseOverMatch = overCircle(xCoord, yCoord, diameter);                if (mouseOverMatch) { break; }            }            if (mouseOverMatch && !previousMouseOverMatch ||                !mouseOverMatch && previousMouseOverMatch) {                redraw();                String matches = confScoreDelta[delta][2];                String[] matchList = split(matches, '|');                // Ajax call which, upon callback, triggers displayMatches()                String uriList = getMatches(matchList);                displayBubble(xCoord, yCoord, diameter, leftScore, rightScore, quantity);            }        } else { redraw(); }    }}void displayBubble(xCoord, yCoord, diameter, leftScore, rightScore, quantity) { /* Prepare text */    String confScores = "[ " + leftScore + ", " + rightScore + " ]";    String numberOfMatches;    if (quantity == 1) { numberOfMatches = quantity + " match"; }    else               { numberOfMatches = quantity + " matches"; }    // determine which text string is longer, and    // base the bubble width on that measurement    int txtWidth;    if (textWidth(confScores) > textWidth(numberOfMatches)) {        txtWidth = textWidth(confScores);    } else {        txtWidth = textWidth(numberOfMatches);    } /* Render popup box */    float topBound = yCoord - 22;   // height of bubble is 44px                                    // (not including outline)    stroke(colours.get(2), 110);    strokeJoin(ROUND);    fill(#ffffff);    // If chosen dot is on the left side of the chart, display box    // to the right of the dot, otherwise, display to the left    if (xCoord < (RIGHT_BOUND - LEFT_BOUND)) {        // display to the right        float leftBound = xCoord + 10;        beginShape();          vertex(leftBound, topBound);          vertex(leftBound + txtWidth + 14, topBound);          vertex(leftBound + txtWidth + 14, topBound + 44);          vertex(leftBound, topBound + 44);          vertex(leftBound, topBound + 24);          vertex(leftBound - 5, topBound + 22);          vertex(leftBound, topBound + 20);          vertex(leftBound, topBound);        endShape();    } else {        // display to the left        float leftBound = xCoord - txtWidth - 24;        beginShape();          vertex(leftBound, topBound);          vertex(leftBound + txtWidth + 14, topBound);          vertex(leftBound + txtWidth + 14, topBound + 20);          vertex(leftBound + txtWidth + 19, topBound + 22);          vertex(leftBound + txtWidth + 14, topBound + 24);          vertex(leftBound + txtWidth + 14, topBound + 44);          vertex(leftBound, topBound + 44);          vertex(leftBound, topBound);        endShape();    }    /* Display text */        fill(80);        text(numberOfMatches,             leftBound + 7 + (txtWidth - textWidth(numberOfMatches))/2,             topBound + 16);        text(confScores,             leftBound + 7 + (txtWidth - textWidth(confScores))/2,             topBound + 35);}void displayMatches(matches) {    // Base box width upon the widest string pair    int boxWidth;    for (int i=0; i<matches.length; i++) {        if ((textWidth(matches[i].e1) + textWidth("   ") + textWidth(matches[i].e2)) > boxWidth) {            boxWidth = (textWidth(matches[i].e1) + textWidth("   ") + textWidth(matches[i].e2));        }    }    boxWidth += 20;  // add 10px padding to each side    // Base box height upon the number of matches    int boxHeight = (matches.length-1) * 20 + 30;    stroke(#e7e5da);    strokeJoin(ROUND);    fill(#ffffff, 150);    beginShape();      vertex(16, 10);      vertex(10 + boxWidth, 10);      vertex(10 + boxWidth, 10 + boxHeight);      vertex(10, 10 + boxHeight);      vertex(10, 16);    endShape();    arc(16, 16, 12, 12, PI, TWO_PI-PI/2);    // print matches    fill(80);    // if remaining matches exist, display text at bottom of list    if (matches[matches.length-1].remaining != null) {        for (int i=0; i<matches.length-1; i++) {            text(matches[i].e1 + "   " + matches[i].e2, 19, 29 + i*20);        }        text("  ... " + matches[matches.length-1].remaining + " more",             19,             29 + (matches.length-1)*20);    } else {        for (int i=0; i<matches.length; i++) {            text(matches[i].e1 + "   " + matches[i].e2, 19, 29 + i*20);        }    }}// taken from http://processingjs.org/learning/topic/rolloverboolean overCircle(int x, int y, int diameter) {    float disX = x - mouseX;    float disY = y - mouseY;    if(sqrt(sq(disX) + sq(disY)) < diameter/2 ) {        return true;    } else {        return false;    }}