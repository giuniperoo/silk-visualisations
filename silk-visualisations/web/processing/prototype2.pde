/****************************************************************** * name:        Prototype 2                                       * *                                                                * * description: Depicts a comparison of matches from two files.   * *              Matches are vertically stacked according to their * *              confidence scores; each row shows the number of   * *              matches that occur in both files in relation to   * *              those that occur independently.                   * *                                                                * * date:        July 2011                                         * * author:      tgiunipero                                        * * version:     1.0                                               * ******************************************************************/// Chart parametersint TOP_BOUND = 50;int LEFT_BOUND = 250;int RIGHT_BOUND = 800;int BOTTOM_BOUND = 490;// y-coordinate of central vertical axisint median;// number of rows to displayint rowNumber;// Text for y axisString yAxisText;// Row height in pixelsfloat rowHeight;// Float values mark the start of each row along y-axisfloat[] rowRanges;// Width of each unit (in pixels) plotted along x-axis// e.g., if there are 8 units in column n, n will be 8*unitWidth wideint unitWidth;// Upper bound for maximum number of matchesint upperBound;// Confidence score range per groupingfloat confidenceScoreRangePerGrouping;// Range of the upper and lower confidence score thresholdsfloat thresholdRange;void setup() { /* Initialise canvas properties */    noLoop();    size(850, 560);    yAxisText = "confidence score";    textFont(createFont("trebuchet ms",13));    median = (RIGHT_BOUND-LEFT_BOUND)/2 + LEFT_BOUND; /* Initialise colour palette */    colours = new ArrayList();    colours.add(RED);    colours.add(BLUE);    colours.add(PURPLE);}void draw() {    fill(80);    stroke(80);    textSize(13);    background(#fcfcfc);    // clears screen for redraw /* Initialise row properties */    // base rows on grouping number    rowNumber = groupingNumber;    rowHeight = getRowHeight();    rowRanges = new float[rowNumber];    // Divide rows by pixel ranges    for (int i=0; i<rowNumber; i++) {        rowRanges[i] = rowHeight * i;    } /* Render chart axes if at least one file is loaded */    if (sketchData.length > 1) {     /* Display axes */        line(LEFT_BOUND, BOTTOM_BOUND, RIGHT_BOUND, BOTTOM_BOUND);        // x-axis        stroke(180);                                  // draw vertical axis lighter        line((RIGHT_BOUND-LEFT_BOUND)/2 + LEFT_BOUND,                     // y-axis             TOP_BOUND-1,             (RIGHT_BOUND-LEFT_BOUND)/2 + LEFT_BOUND,             BOTTOM_BOUND-1);        stroke(80);        // confidence score axis        line(LEFT_BOUND-1, TOP_BOUND-1, LEFT_BOUND-1, BOTTOM_BOUND-1);     /* Display ticks */        line(RIGHT_BOUND, BOTTOM_BOUND+1, RIGHT_BOUND, BOTTOM_BOUND+5);   // right tick        // confidence score axis        line(LEFT_BOUND-2, TOP_BOUND-1, LEFT_BOUND-6, TOP_BOUND-1);       // top tick     /* Display '0' along x-axis */        textSize(16);        text("0", (LEFT_BOUND + RIGHT_BOUND -1)/2 - textWidth("0")/2, BOTTOM_BOUND + 20);        textSize(13);     /* Text along y-axis, i.e., "confidence score" */        textSize(18);        pushMatrix();        rotate(-HALF_PI);        text(yAxisText,             -((TOP_BOUND + BOTTOM_BOUND)/2 + textWidth(yAxisText)/2) + 1,   // x-coordinate             LEFT_BOUND-50);                                                 // y-coordinate        popMatrix();        // Get maximum value from loaded groupings        int maxValue = getMaxValue();        // Set upper bound for x-axis        upperBound = getUpperBound(maxValue);        // Set unit width according to upperBound        setUnitWidth(upperBound);        // max quantity of links        textSize(13);        text(upperBound, LEFT_BOUND - textWidth(upperBound)/2, BOTTOM_BOUND + 20);        text(upperBound, RIGHT_BOUND - textWidth(upperBound)/2, BOTTOM_BOUND + 20);        // confidence score thresholds        text(lowerThreshold, LEFT_BOUND - 11 - textWidth(lowerThreshold), BOTTOM_BOUND + 4);        text(upperThreshold, LEFT_BOUND - 16 - textWidth(upperThreshold), TOP_BOUND + 4);        // Display intermediate measures        displayIntermediateMeasures();    /* Text along x-axis */        textSize(15);        // Left file        int firstIdx = currentlySelected[0].fileIdx;        leftFileName = fileData[firstIdx].name;        text(leftFileName,            (LEFT_BOUND + ((LEFT_BOUND + RIGHT_BOUND)/2 - LEFT_BOUND)/2 - textWidth(leftFileName)/2),            BOTTOM_BOUND + textAscent()+34);        // Right file        int secondIdx = currentlySelected[1].fileIdx;        rightFileName = fileData[secondIdx].name;        text(rightFileName,            (LEFT_BOUND + 3*((LEFT_BOUND + RIGHT_BOUND)/2 - LEFT_BOUND)/2 - textWidth(rightFileName)/2),            BOTTOM_BOUND + textAscent()+34);     /* Display shared matches */        noStroke();        fill(colours.get(2));                                       // bar colour set to purple        // left file        for (int i=0; i<rowNumber; i++) {            if (leftSharedMatchCount[i] != 0) {                rowWidth = leftSharedMatchCount[i] * unitWidth;                rect(median - rowWidth,                             // x-coordinate                     BOTTOM_BOUND - rowHeight - rowRanges[i] - 1,   // y-coordinate                     rowWidth,                                      // width                     rowHeight-1);                                  // height            }        }        // right file        for (int i=0; i<rowNumber; i++) {            if (rightSharedMatchCount[i] != 0) {                rowWidth = rightSharedMatchCount[i] * unitWidth;                rect(median,                                        // x-coordinate                     BOTTOM_BOUND - rowHeight - rowRanges[i] - 1,   // y-coordinate                     rowWidth,                                      // width                     rowHeight-1);                                  // height            }        }     /* Display unique matches */        // left file        fill(colours.get(0));                                       // bar colour set to red        for (int i=0; i<rowNumber; i++) {            if (leftUniqueCount[i] != 0) {                rowWidth = leftUniqueCount[i] * unitWidth;                xCoord = (median - (leftSharedMatchCount[i] * unitWidth)) - rowWidth;                rect(xCoord,                                        // x-coordinate                     BOTTOM_BOUND - rowHeight - rowRanges[i] - 1,   // y-coordinate                     rowWidth,                                      // width                     rowHeight-1);                                  // height            }        }        // right file        fill(colours.get(1));                                       // bar colour set to blue        for (int i=0; i<rowNumber; i++) {            if (rightUniqueCount[i] != 0) {                rowWidth = rightUniqueCount[i] * unitWidth;                xCoord = (median + (rightSharedMatchCount[i] * unitWidth));                rect(xCoord,                                        // x-coordinate                     BOTTOM_BOUND - rowHeight - rowRanges[i] - 1,   // y-coordinate                     rowWidth,                                      // width                     rowHeight-1);                                  // height            }        }     /* Get results for independent/shared matches */        fill(80);        stroke(80);        int leftCount, rightCount,            leftSharedCount, rightSharedCount;        for (int i=0; i<leftUniqueCount.length; i++) {            leftCount += leftUniqueCount[i];        }        for (int i=0; i<rightUniqueCount.length; i++) {            rightCount += rightUniqueCount[i];        }        for (int i=0; i<leftSharedMatchCount.length; i++) {            leftSharedCount += leftSharedMatchCount[i];        }     /* Display box for independent/shared matches */        // base width on length of longest text string        textSize(12);        if (textWidth(leftFileName + ":  " + leftCount) >            textWidth(rightFileName + ":  " + rightCount)) {            txtWidth = textWidth(leftFileName + ":  " + leftCount);        } else {            txtWidth = textWidth(rightFileName + ":  " + rightCount);        }        // ensure that file name is longer than "Independent matches"        textSize(13);        if (txtWidth < textWidth("Independent matches") - 10) {  // 10px accounts for indent            txtWidth = textWidth("Independent matches") - 10;        }        strokeJoin(ROUND);        fill(#e7e5da);        noStroke();        beginShape();          vertex(10, height-16);          vertex(10, height-120);          vertex(txtWidth+40, height-120);          vertex(txtWidth+40, height-10);          vertex(16, height-10);        endShape();        arc(16, height-16, 12, 12, PI/2, PI);        fill(80);        stroke(80);     /* Display results for independent/shared matches */        text("Shared matches", 20, height-100);        textSize(12);        text("Each file:  " + leftSharedCount, 30, height-80);        textSize(13);        text("Independent matches", 20, height-60);        textSize(12);        text(leftFileName + ":  " + leftCount, 30, height-40);        text(rightFileName + ":  " + rightCount, 30, height-20);    } /* Uncomment for testing */    // if (sketchData.length != 0) {inspectGlobalVars();}}void displayIntermediateMeasures() {    textSize(12);   // smaller text  /* ------------------- x-axis ------------------ *   * Divide upperBound by 4 or 5 and display each. */    int unit, divisor = 4;              // Attempt to get integer values for    if (upperBound%4 == 0) {            // intermediate numbers. If division        unit = upperBound/4;            // by four does not create integer    } else if (upperBound%5 == 0) {     // values, try five. Otherwise revert        unit = upperBound/5;            // to four.        divisor = 5;    } else {        unit = upperBound/4;    }    int width = (RIGHT_BOUND - LEFT_BOUND)/2;    int unitWidth = width/divisor;    for (int i=1; i<divisor; i++) {        txt = i.toString().slice(0,4);        text(unit*i,             (RIGHT_BOUND-LEFT_BOUND)/2 + LEFT_BOUND - unitWidth*i - textWidth(unit*i)/2,             (BOTTOM_BOUND + 20));        text(unit*i,             (RIGHT_BOUND-LEFT_BOUND)/2 + LEFT_BOUND + unitWidth*i - textWidth(unit*i)/2,             (BOTTOM_BOUND + 20));        stroke(#fcfcfc);        strokeWeight(2);        line((RIGHT_BOUND-LEFT_BOUND)/2 + LEFT_BOUND - unitWidth*i,             (BOTTOM_BOUND-1),             (RIGHT_BOUND-LEFT_BOUND)/2 + LEFT_BOUND - unitWidth*i,             (BOTTOM_BOUND+1));        line((RIGHT_BOUND-LEFT_BOUND)/2 + LEFT_BOUND + unitWidth*i,             (BOTTOM_BOUND-1),             (RIGHT_BOUND-LEFT_BOUND)/2 + LEFT_BOUND + unitWidth*i,             (BOTTOM_BOUND+1));        stroke(80);        strokeWeight(1);    }  /* -------------------------- y-axis -------------------------- *   * If there are less than 5 tenths to display, display median   *   * values between tenths. Otherwise, only display tenth values. */    // get height in pixels per tenth unit    heightInPixels = BOTTOM_BOUND - TOP_BOUND;    float thresholdRange = (upperThreshold - lowerThreshold);    int j=1;    if (thresholdRange/.1 < 5) {        numberOfTwentieths = thresholdRange*20;        heightPerUnit = heightInPixels/numberOfTwentieths;        for (int i=float(lowerThreshold)+.05; i<float(upperThreshold); i+=.05) {            i = round(i*100)/100;   // avoids long floats, e.g. '0.6999999999999'            // prepare text            txt = i.toString().slice(0,4);            // display text            text(txt,                 LEFT_BOUND - 11 - textWidth(txt),         // x-coordinate                 (BOTTOM_BOUND + 4) - heightPerUnit*j);    // y-coordinate            // display tick            stroke(#fcfcfc);            strokeWeight(2);            line(LEFT_BOUND,                 BOTTOM_BOUND - heightPerUnit*j - 1,                 LEFT_BOUND-2,                 BOTTOM_BOUND - heightPerUnit*j - 1);            stroke(80);            strokeWeight(1);            j++;        }    } else {        for (int i=float(lowerThreshold)+.1; i<float(upperThreshold); i+=.1) {            numberOfTenths = thresholdRange*10;            heightPerUnit = heightInPixels/numberOfTenths;            i = round(i*10)/10;               // avoids long floats            txt = i.toString().slice(0,3);    // prepare text            // display text            text(txt,                 LEFT_BOUND - 11 - textWidth(txt),         // x-coordinate                 (BOTTOM_BOUND + 4) - heightPerUnit*j);    // y-coordinate            // display tick            stroke(#fcfcfc);            strokeWeight(2);            line(LEFT_BOUND,                 BOTTOM_BOUND - heightPerUnit*j - 1,                 LEFT_BOUND-2,                 BOTTOM_BOUND - heightPerUnit*j - 1);            stroke(80);            strokeWeight(1);            j++;        }    }}/* Output to console the global variables defined for this run */void inspectGlobalVars() {    println("Chart boundaries:");    println("----------------------------");    println("\tLEFT_BOUND:\t" + LEFT_BOUND);    println("\tRIGHT_BOUND:\t" + RIGHT_BOUND);    println("\tTOP_BOUND:\t" + TOP_BOUND);    println("\tBOTTOM_BOUND:\t" + BOTTOM_BOUND);    println("----------------------------");    println("Number of rows:\t" + rowNumber);    println("Row height:\t\t" + rowHeight);    println("Unit width:\t\t" + unitWidth);    println("Max value for x-axis:\t" + getMaxValue());    println("----------------------------");    println("Starting points for each row along y-axis:");    for (int i = 0; i < rowRanges.length; i++) {        println(rowRanges[i]);    }}/* Popup functionality */void mouseMoved() {    if (sketchData.length > 1) {        redraw();        // Check if mouse is being hovered over the chart        if ( mouseX >= LEFT_BOUND && mouseX <= RIGHT_BOUND &&             mouseY >= TOP_BOUND && mouseY <= BOTTOM_BOUND ) {            redraw();            // If so, determine which row            currentRow = null;            for (int i=0; i<rowRanges.length; i++) {                if (mouseY >= BOTTOM_BOUND - rowRanges[i] - rowHeight) {                    currentRow = i;                    break;                }            }            // Determine which row segment the mouse is over            int quantity;            float sharedRowWidth, uniqueRowWidth, leftRowBorder;            // Determine whether mouse is to the left or right of the central axis            if (mouseX < median) {          // mouse is left                quantity = leftSharedMatchCount[currentRow];                sharedRowWidth = quantity * unitWidth;                leftRowBorder = median - sharedRowWidth;                // If mouse is within range...                if (mouseX >= leftRowBorder) {                    // and if matches exist...                    if (quantity != 0) {                        // highlight row segment and display details bubble                        highlightRow(currentRow, 2, leftRowBorder, sharedRowWidth);                        displayBubble(currentRow, 2, leftRowBorder, sharedRowWidth);                    }                } else {                    // get unique match count                    quantity = leftUniqueCount[currentRow];                    uniqueRowWidth = quantity * unitWidth;                    // get left border of row                    leftRowBorder = median - sharedRowWidth - uniqueRowWidth;                    if (mouseX >= leftRowBorder) {                        if (quantity != 0) {                            highlightRow(currentRow, 0, leftRowBorder, uniqueRowWidth);                            displayBubble(currentRow, 0, leftRowBorder, uniqueRowWidth);                        }                    }                }            } else if (mouseX > median) {   // mouse is right of central axis                // get shared match count                quantity = rightSharedMatchCount[currentRow];                sharedRowWidth = quantity * unitWidth;                if (mouseX <= (median + sharedRowWidth) + 1) {                    if (quantity != 0) {                        highlightRow(currentRow, 2, median, sharedRowWidth);                        displayBubble(currentRow, 2, median, sharedRowWidth);                    }                } else {                    // get unique match count                    quantity = rightUniqueCount[currentRow];                    uniqueRowWidth = quantity * unitWidth;                    // get left border of row                    leftRowBorder = median + sharedRowWidth;                    if (mouseX <= leftRowBorder + uniqueRowWidth + 1) {                        if (quantity != 0) {                            highlightRow(currentRow, 1, leftRowBorder, uniqueRowWidth);                            displayBubble(currentRow, 1, leftRowBorder, uniqueRowWidth);                        }                    }                }            }        }    }}void highlightRow(row, colourIdx, leftBorder, rowWidth) {    // top border    topBound = BOTTOM_BOUND - rowRanges[row] - rowHeight;    fill(colours.get(colourIdx), 100);    stroke(colours.get(colourIdx), 110);    // render popup column    rect(leftBorder, topBound-1, rowWidth, rowHeight-1);}void displayBubble(row, colourIdx, leftBorder, rowWidth) { /* Get details */    thresholdRange = (upperThreshold - lowerThreshold);    confidenceScoreRangePerGrouping =            thresholdRange / groupingNumber;    // get confidence score range for selected row    int lowerValue = (row * confidenceScoreRangePerGrouping) + float(lowerThreshold);    int upperValue = lowerValue + confidenceScoreRangePerGrouping;    // display only 3 significant digits    lowerValue = round(lowerValue*1000)/1000;    upperValue = round(upperValue*1000)/1000;    // get number of matches for the selected row    int quantity = int(rowWidth/unitWidth);    // determine whether matches are shared or unique    String matchType;    if (colourIdx == 2) {        if (quantity == 1) { matchType = " shared match"; }        else { matchType = " shared matches"; }    } else {        if (quantity == 1) { matchType = " independent match"; }        else { matchType = " independent matches"; }    }    // prepare text    String quantityText = quantity + matchType;    String rangeText = "Range: " + lowerValue + " - " + upperValue;    // determine which text string is longer, and    // base the bubble width on that measurement    int txtWidth;    if (textWidth(quantityText) > textWidth(rangeText)) {        txtWidth = textWidth(quantityText);    } else {        txtWidth = textWidth(rangeText);    } /* Render popup box */    // left border    float leftBound = leftBorder + rowWidth/2 - txtWidth/2 - 7;    // right border    float rightBound = leftBorder + rowWidth/2 + txtWidth/2 + 7;    strokeJoin(ROUND);    fill(#ffffff);    // If chosen row is higher than three fourths the height    // of the canvas, display bubble and text below the row.    if ((BOTTOM_BOUND - TOP_BOUND - rowRanges[row]) < (BOTTOM_BOUND - TOP_BOUND)/4) {        // top border        float topBound = BOTTOM_BOUND - rowRanges[row];        beginShape();          vertex(leftBound, topBound + 7);          vertex(leftBound, topBound + 52);          vertex(rightBound, topBound + 52);          vertex(rightBound, topBound + 7);          vertex(leftBorder + rowWidth/2 + 3, topBound + 7);          vertex(leftBorder + rowWidth/2, topBound + 2);          vertex(leftBorder + rowWidth/2 - 3, topBound + 7);          vertex(leftBound, topBound + 7);        endShape();    /* Display text */        fill(80);        text(quantityText,             leftBorder + rowWidth/2 - textWidth(quantityText)/2,             topBound + 24);        text(rangeText,             leftBorder + rowWidth/2 - textWidth(rangeText)/2,             topBound + 43);    } else {        // top border        float topBound = BOTTOM_BOUND - rowRanges[row] - rowHeight;        beginShape();          vertex(leftBound, topBound - 7);          vertex(leftBound, topBound - 52);          vertex(rightBound, topBound - 52);          vertex(rightBound, topBound - 7);          vertex(leftBorder + rowWidth/2 + 3, topBound - 7);          vertex(leftBorder + rowWidth/2, topBound - 2);          vertex(leftBorder + rowWidth/2 - 3, topBound - 7);          vertex(leftBound, topBound - 7);        endShape();    /* Display text */        fill(80);        text(quantityText,             leftBorder + rowWidth/2 - textWidth(quantityText)/2,             topBound - 35);        text(rangeText,             leftBorder + rowWidth/2 - textWidth(rangeText)/2,             topBound - 16);    }}